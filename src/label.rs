
/// Trait to enforce value() and from() consistency across the enums
pub trait SerializableEnum<T> {
    fn value(&self) -> String;
    fn from(s:&String) -> Option<T>;
}

///////////////////////
/// Format
///////////////////////

pub enum Format {
    BYTE,       // one byte unsigned integer, range 0 to 255.
    HALF,       // two byte signed integer, range -32768 to 32767.
    FULL,       // four byte signed integer.
    REAL,       // single-precision floating point number.
    DOUB,       // double-precision floating point number.
    COMP,       // complex number, composed of two REALs in the order (real, imaginary).
    WORD,       // Same as HALF
    LONG,       // Same as FULL
    COMPLEX     // Same as COMP
}

impl SerializableEnum<Format> for Format {
    fn value(&self) -> String {
        String::from(match *self {
            Format::BYTE => "BYTE",
            Format::HALF => "HALF",
            Format::FULL => "FULL",
            Format::REAL => "REAL",
            Format::DOUB => "DOUB",
            Format::COMP => "COMP",
            Format::WORD => "WORD",
            Format::LONG => "LONG",
            Format::COMPLEX => "COMPLEX"
        })
    }

    fn from(s:&String) -> Option<Format> {
        match s.to_uppercase().as_str() {
            "BYTE" => Some(Format::BYTE),
            "HALF" => Some(Format::HALF),
            "FULL" => Some(Format::FULL),
            "REAL" => Some(Format::REAL),
            "DOUB" => Some(Format::DOUB),
            "COMP" => Some(Format::COMP),
            "WORD" => Some(Format::WORD),
            "LONG" => Some(Format::LONG),
            "COMPLEX" => Some(Format::COMPLEX),
            _ => None
        }
    }
}

///////////////////////
/// Type
///////////////////////

pub enum Type {
    IMAGE,              // standard VICAR image file. 
    PARMS,              // very old-style parameter file.
    PARM,               // old-style parameter file.
    PARAM,              // current parameter file, used to hold input parameters for one VICAR program
                        // that were generated by another. Created by the x/zvpopen and x/zvpout routines in the
                        // VICAR Run-Time Library.
    GRAPH1,             // IBIS Graphics-1 file.
    GRAPH2,             // IBIS Graphics-2 file.
    GRAPH3,             // IBIS Graphics-3 file.
    TABULAR             // IBIS Tabular file
}

impl SerializableEnum<Type> for Type {
    fn value(&self) -> String {
        String::from(match *self {
            Type::IMAGE => "IMAGE",
            Type::PARMS => "PARMS",
            Type::PARM => "PARM",
            Type::PARAM => "PARAM",
            Type::GRAPH1 => "GRAPH1",
            Type::GRAPH2 => "GRAPH2",
            Type::GRAPH3 => "GRAPH3",
            Type::TABULAR => "TABULAR"
        })
    }

    fn from(s:&String) -> Option<Type> {
        match s.to_uppercase().as_str() {
            "IMAGE" => Some(Type::IMAGE),
            "PARMS" => Some(Type::PARMS),
            "PARM" => Some(Type::PARM),
            "PARAM" => Some(Type::PARAM),
            "GRAPH1" => Some(Type::GRAPH1),
            "GRAPH2" => Some(Type::GRAPH2),
            "GRAPH3" => Some(Type::GRAPH3),
            _ => None
        }
    }
}

///////////////////////
/// Org
///////////////////////

pub enum Org {
    BSQ,        // Band SeQuential. N1=Samples, N2=Lines, N3=Bands
    BIL,        // Band interleaved by line. N1=Samples, N2=Bands, N3=Lines
    BIP         // Band interleaved by pixel. N1=Bands, N2=Samples, N3=Lines
}

impl SerializableEnum<Org> for Org {
    fn value(&self) -> String {
        String::from(match *self {
            Org::BSQ => "BSQ",
            Org::BIL => "BIL",
            Org::BIP => "BIP"
        })
    }

    fn from(s:&String) -> Option<Org> {
        match s.to_uppercase().as_str() {
            "BSQ" => Some(Org::BSQ),
            "BIL" => Some(Org::BIL),
            "BIP" => Some(Org::BIP),
            _ => None
        }
    }
}

///////////////////////
/// Host
///////////////////////

pub enum Host {
    ALLIANT,        // Alliant FX series computer.
    CRAY,           // Cray (port is incomplete, and Cray format is not yet supported).
    DECSTATN,       // DECstation (any DEC MIPS-based RISC machine) running Ultrix.
    HP700,          // HP 9000 Series 700 workstation
    MACAUX,         // Macintosh running A/UX.
    MACMPW,         // Macintosh running native mode with Mac Programmers Workbench
    SGI,            // Silicon Graphics workstation
    SUN3,           // Sun 3, any model.
    SUN4,           // Sun 4 or SPARCstation, or clone such as Solbourne.
    TEK,            // Tektronix workstation.
    VAXVMS          // VAX running VMS
}

impl SerializableEnum<Host> for Host {
    fn value(&self) -> String {
        String::from(match *self {
            Host::ALLIANT => "ALLIANT",
            Host::CRAY => "CRAY",
            Host::DECSTATN => "DECSTATN",
            Host::HP700 => "HP-700",
            Host::MACAUX => "MAC-AUX",
            Host::MACMPW => "MAC-MPW",
            Host::SGI => "SGI",
            Host::SUN3 => "SUN-3",
            Host::SUN4 => "SUN-4",
            Host::TEK => "TEK",
            Host::VAXVMS => "VAX-VMS"
        })
    }

    fn from(s:&String) -> Option<Host> {
        match s.to_uppercase().as_str() {
            "ALLIANT" => Some(Host::ALLIANT),
            "CRAY" => Some(Host::CRAY),
            "DECSTATN" => Some(Host::DECSTATN),
            "HP-700" => Some(Host::HP700),
            "MAC-AUX" => Some(Host::MACAUX),
            "MAC-MPW" => Some(Host::MACMPW),
            "SGI" => Some(Host::SGI),
            "SUN-3" => Some(Host::SUN3),
            "SUN-4" => Some(Host::SUN4),
            "TEK" => Some(Host::TEK),
            "VAX-VMS" => Some(Host::VAXVMS),
            _ => None
        }
    }
}

///////////////////////
/// INTFMT
///////////////////////

pub enum IntFmt {
    HIGH,           // High byte first, big endian. 
    LOW             // Low byte first, little endian.
}


impl SerializableEnum<IntFmt> for IntFmt {
    fn value(&self) -> String {
        String::from(match *self {
            IntFmt::HIGH => "HIGH",
            IntFmt::LOW => "LOW"
        })
    }

    fn from(s:&String) -> Option<IntFmt> {
        match s.to_uppercase().as_str() {
            "HIGH" => Some(IntFmt::HIGH),
            "LOW" => Some(IntFmt::LOW),
            _ => None
        }
    }
}

///////////////////////
/// RealFmt
///////////////////////

pub enum RealFmt {
    IEEE,           // IEEE 754 format, with the high-order bytes (containing the exponent) first. Used
                    // for all other hosts (except for Cray, which is unimplemented).
    RIEEE,          // Reverse IEEE format. Just like IEEE, except the bytes are reversed, with the
                    // exponent last. Used for host DECSTATN only
    VAX             // VAX format. Single precision is in VAX F format, double precision is in VAX D
                    // format. Used for host VAX-VMS only.
}

impl SerializableEnum<RealFmt> for RealFmt {
    fn value(&self) -> String {
        String::from(match *self {
            RealFmt::IEEE => "IEEE",
            RealFmt::RIEEE => "RIEEE",
            RealFmt::VAX => "VAX"
        })
    }

    fn from(s:&String) -> Option<RealFmt> {
        match s.to_uppercase().as_str() {
            "IEEE" => Some(RealFmt::IEEE),
            "RIEEE" => Some(RealFmt::RIEEE),
            "VAX" => Some(RealFmt::VAX),
            _ => None
        }
    }
}



///////////////////////
/// SystemLabel
/// 
/// System labels describe the format of the image and how to access it. They are always the first labels in the
/// file. The system labels extend from the beginning of the file until the first PROPERTY or TASK keyword,
/// or until the end of the label (if there are no property or history labels).
/// 
///////////////////////


pub enum SystemLabel {
    LBLSIZE,            // integer - The size of the label storage area, in bytes
    FORMAT,             // string enum BYTE, HALF, FULL, REAL, DOUB, COMP, WORD, LONG, COMPLEX
                        //              The data type of the pixels in the image.
    TYPE,               // string enum IMAGE PARMS PARM PARAM GRAPH1 GRAPH2 GRAPH3
                        //              The kind of file this is.
    BUFSIZE,            // integer - This label item is obsolete. It formerly defined the size of the
                        //              internal buffer to use when reading the image, but it is no longer used.
    DIM,                // integer - The number of dimensions in the file, which is always equal to 3.
    EOL,                // integer - A flag indicating the existence of EOL labels (see above). If EOL=1, the labels are
                        //              present. If EOL=0 (or is absent), no EOL labels are present, and the entire label string is at the
                        //              front of the file.
    RECSIZE,            // integer - The size in bytes of each record in the VICAR file. It may be
                        //              calculated with the formula NBB + N1*pixel_size, where pixel_size is the size of each pixel
                        //              computed using FORMAT (for the pixel type) and the INTFMT or REALFMT (for the host
                        //              representation) labels.
    ORG,                // string - The organization of the file. 
    NL,                 // integer - The number of lines in the image (same as N2 for BSQ or N3 for BIL and BIP)
    NS,                 // integer - Number of samples in the image (same as N1 for BSQ and BIL or N2 for BIP).
    NB,                 // integer - Number of bands in the image (same as N3 for BSQ, N2 for BIL, or N1 for BIP)
    N1,                 // integer - The size (in pixels) of the first (fastest-varying) dimension. If not present, it defaults
                        //              to NS or NB, as appropriate.
    N2,                 // integer - The size of the second dimension. If not present, it defaults to NL, NS, or NB, as
                        //              appropriate
    N3,                 // integer - The size of the third (slowest-varying) dimension. If not present, it defaults to NL or
                        //              NB, as appropriate.
    N4,                 // integer - This item was to have been used for four-dimensional files, but this has not yet been
                        //              implemented. It defaults to 0.
    NBB,                // integer - The number of bytes of binary prefix before each record. Each and every record
                        //              consists of the pixels of the fastest-varying dimension, optionally preceded by a binary prefix. The
                        //              size (in bytes, not pixels) of this binary prefix is given by NBB, which defaults to 0. The binary
                        //              prefix and the binary header (see NLB) together make up the binary label. The format of data in
                        //              the binary label is application-defined. The BLTYPE label is intended to identify the format of the
                        //              binary label, but it is new and not widely used. Generally, the binary label should be ignored
                        //              unless the format of the data is known beforehand
    NLB,                // integer - The number of lines (records) of binary header at the top of the file. The optional
                        //              binary header occurs once in the file, between the main labels and the image data. It is not
                        //              repeated per third dimension. The size of the binary header in bytes is given by NLB * RECSIZE,
                        //              since NLB is a line count. NLB defaults to 0. Note that the binary header also includes space
                        //              reserved for the binary prefix (NBB), since NBB goes into RECSIZE. The binary header and the
                        //              binary prefix (see NBB) together make up the binary label. The format of data in the binary label
                        //              is application-defined. The BLTYPE label is intended to identify the format of the binary label,
                        //              but it is new and not widely used. Generally, the binary label should be ignored unless the format
                        //              of the data is known beforehand
    HOST,               // string enum - The type of computer used to generate the image. It is used only for documentation;
                        //              the INTFMT and REALFMT labels are used to determine the format of the pixels. Nevertheless, it
                        //              should be kept consistent with INTFMT and REALFMT. HOST defaults to VAX-VMS. The
                        //              value may be anything, as new computer types are occasionally added,
    INTFMT,             // string enum - The format used to represent integer pixels (BYTE, HALF, and FULL) in the
                        //              file. If INTFMT is not present, it defaults to LOW. Note that INTFMT should be present even if
                        //              the pixels are a floating-point type. T
    REALFMT,            // string enum - The format used to represent floating-point pixels (REAL, DOUB, and
                        //              COMP) in the file. If REALFMT is not present, it defaults to VAX. Note that REALFMT should
                        //              be present even if the pixels are an integral type.
    BHOST,              // string - The type of computer used to generate the binary label. It can take the same
                        //              values with the same meanings as HOST. The reason BHOST is separate is that the data in the
                        //              binary label may be in a different host representation than the pixels
    BINTFMT,            // string - The format used to represent integers in the binary label. It can take the same
                        //              values with the same meanings as INTFMT. The reason BINTFMT is separate is that the data in
                        //              the binary label may be in a different host representation than the pixels.
    BREALFMT,           // string - The format used to represent floating-point data in the binary label. It can
                        //              take the same values with the same meanings as REALFMT. The reason BREALFMT is separate
                        //              is that the data in the binary label may be in a different host representation than the pixels
    BLTYPE,             // string - The type of the binary label. This is not a data type, but is a string identifying the
                        //              kind of binary label in the file. It is used for documentation, and so application programs can
                        //              process the binary label correctly, without having to be told what kind it is. BLTYPE is new, and
                        //              is not yet used by any applications. It defaults to a null string. The valid values are maintained in a
                        //              name registry by the VICAR system programmer, which will document the actual data layout for
                        //              each BLTYPE. As of this writing, there are no names yet registered
}

/*
Each keyword-value pair is separated by spaces. Keywords are strings, up to 32
characters in length, and consist of uppercase characters, underscores (_), and numbers (but should start
with a letter). Values may be integer, real, or strings, and may be multiple (e.g. an array of 5 integers, but
types cannot be mixed in a single value). Spaces may appear on either side of the equals character (=), but
are not normally present.

The label values may be of three types: integer, real, or string
*/
pub struct KeyValuePair<T> {
    pub key:String,
    pub value:T
}

// impl<T> KeyValuePair<T> {

//     pub fn parse(s:String) -> KeyValuePair<T> {

//     }

// }