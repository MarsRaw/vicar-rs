


/// Trait to enforce value() and from() consistency across the enums
pub trait Serializable {
    fn value(&self) -> String;
    fn from(s:&String) -> Option<Box<Self>>;
}

///////////////////////
/// Format
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Format {
    BYTE,       // one byte unsigned integer, range 0 to 255.
    HALF,       // two byte signed integer, range -32768 to 32767.
    FULL,       // four byte signed integer.
    REAL,       // single-precision floating point number.
    DOUB,       // double-precision floating point number.
    COMP,       // complex number, composed of two REALs in the order (real, imaginary).
    WORD,       // Same as HALF
    LONG,       // Same as FULL
    COMPLEX     // Same as COMP
}

impl Serializable for Format {
    fn value(&self) -> String {
        String::from(match *self {
            Format::BYTE => "BYTE",
            Format::HALF => "HALF",
            Format::FULL => "FULL",
            Format::REAL => "REAL",
            Format::DOUB => "DOUB",
            Format::COMP => "COMP",
            Format::WORD => "WORD",
            Format::LONG => "LONG",
            Format::COMPLEX => "COMPLEX"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "BYTE" => Some(Box::new(Format::BYTE)),
            "HALF" => Some(Box::new(Format::HALF)),
            "FULL" => Some(Box::new(Format::FULL)),
            "REAL" => Some(Box::new(Format::REAL)),
            "DOUB" => Some(Box::new(Format::DOUB)),
            "COMP" => Some(Box::new(Format::COMP)),
            "WORD" => Some(Box::new(Format::WORD)),
            "LONG" => Some(Box::new(Format::LONG)),
            "COMPLEX" => Some(Box::new(Format::COMPLEX)),
            _ => None
        }
    }
}

///////////////////////
/// Type
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Type {
    IMAGE,              // standard VICAR image file. 
    PARMS,              // very old-style parameter file.
    PARM,               // old-style parameter file.
    PARAM,              // current parameter file, used to hold input parameters for one VICAR program
                        // that were generated by another. Created by the x/zvpopen and x/zvpout routines in the
                        // VICAR Run-Time Library.
    GRAPH1,             // IBIS Graphics-1 file.
    GRAPH2,             // IBIS Graphics-2 file.
    GRAPH3,             // IBIS Graphics-3 file.
    TABULAR             // IBIS Tabular file
}

impl Serializable for Type {
    fn value(&self) -> String {
        String::from(match *self {
            Type::IMAGE => "IMAGE",
            Type::PARMS => "PARMS",
            Type::PARM => "PARM",
            Type::PARAM => "PARAM",
            Type::GRAPH1 => "GRAPH1",
            Type::GRAPH2 => "GRAPH2",
            Type::GRAPH3 => "GRAPH3",
            Type::TABULAR => "TABULAR"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "IMAGE" => Some(Box::new(Type::IMAGE)),
            "PARMS" => Some(Box::new(Type::PARMS)),
            "PARM" => Some(Box::new(Type::PARM)),
            "PARAM" => Some(Box::new(Type::PARAM)),
            "GRAPH1" => Some(Box::new(Type::GRAPH1)),
            "GRAPH2" => Some(Box::new(Type::GRAPH2)),
            "GRAPH3" => Some(Box::new(Type::GRAPH3)),
            _ => None
        }
    }
}

///////////////////////
/// Org
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Org {
    BSQ,        // Band SeQuential. N1=Samples, N2=Lines, N3=Bands
    BIL,        // Band interleaved by line. N1=Samples, N2=Bands, N3=Lines
    BIP         // Band interleaved by pixel. N1=Bands, N2=Samples, N3=Lines
}

impl Serializable for Org {
    fn value(&self) -> String {
        String::from(match *self {
            Org::BSQ => "BSQ",
            Org::BIL => "BIL",
            Org::BIP => "BIP"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "BSQ" => Some(Box::new(Org::BSQ)),
            "BIL" => Some(Box::new(Org::BIL)),
            "BIP" => Some(Box::new(Org::BIP)),
            _ => None
        }
    }
}

///////////////////////
/// Host
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Host {
    ALLIANT,        // Alliant FX series computer.
    CRAY,           // Cray (port is incomplete, and Cray format is not yet supported).
    DECSTATN,       // DECstation (any DEC MIPS-based RISC machine) running Ultrix.
    HP700,          // HP 9000 Series 700 workstation
    MACAUX,         // Macintosh running A/UX.
    MACMPW,         // Macintosh running native mode with Mac Programmers Workbench
    SGI,            // Silicon Graphics workstation
    SUN3,           // Sun 3, any model.
    SUN4,           // Sun 4 or SPARCstation, or clone such as Solbourne.
    TEK,            // Tektronix workstation.
    VAXVMS          // VAX running VMS
}

impl Serializable for Host {
    fn value(&self) -> String {
        String::from(match *self {
            Host::ALLIANT => "ALLIANT",
            Host::CRAY => "CRAY",
            Host::DECSTATN => "DECSTATN",
            Host::HP700 => "HP-700",
            Host::MACAUX => "MAC-AUX",
            Host::MACMPW => "MAC-MPW",
            Host::SGI => "SGI",
            Host::SUN3 => "SUN-3",
            Host::SUN4 => "SUN-4",
            Host::TEK => "TEK",
            Host::VAXVMS => "VAX-VMS"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "ALLIANT" => Some(Box::new(Host::ALLIANT)),
            "CRAY" => Some(Box::new(Host::CRAY)),
            "DECSTATN" => Some(Box::new(Host::DECSTATN)),
            "HP-700" => Some(Box::new(Host::HP700)),
            "MAC-AUX" => Some(Box::new(Host::MACAUX)),
            "MAC-MPW" => Some(Box::new(Host::MACMPW)),
            "SGI" => Some(Box::new(Host::SGI)),
            "SUN-3" => Some(Box::new(Host::SUN3)),
            "SUN-4" => Some(Box::new(Host::SUN4)),
            "TEK" => Some(Box::new(Host::TEK)),
            "VAX-VMS" => Some(Box::new(Host::VAXVMS)),
            _ => None
        }
    }
}

///////////////////////
/// INTFMT
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum IntFmt {
    HIGH,           // High byte first, big endian. 
    LOW             // Low byte first, little endian.
}


impl Serializable for IntFmt {
    fn value(&self) -> String {
        String::from(match *self {
            IntFmt::HIGH => "HIGH",
            IntFmt::LOW => "LOW"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "HIGH" => Some(Box::new(IntFmt::HIGH)),
            "LOW" => Some(Box::new(IntFmt::LOW)),
            _ => None
        }
    }
}

///////////////////////
/// RealFmt
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum RealFmt {
    IEEE,           // IEEE 754 format, with the high-order bytes (containing the exponent) first. Used
                    // for all other hosts (except for Cray, which is unimplemented).
    RIEEE,          // Reverse IEEE format. Just like IEEE, except the bytes are reversed, with the
                    // exponent last. Used for host DECSTATN only
    VAX             // VAX format. Single precision is in VAX F format, double precision is in VAX D
                    // format. Used for host VAX-VMS only.
}

impl Serializable for RealFmt {
    fn value(&self) -> String {
        String::from(match *self {
            RealFmt::IEEE => "IEEE",
            RealFmt::RIEEE => "RIEEE",
            RealFmt::VAX => "VAX"
        })
    }

    fn from(s:&String) -> Option<Box<Self>> {
        match s.to_uppercase().as_str() {
            "IEEE" => Some(Box::new(RealFmt::IEEE)),
            "RIEEE" => Some(Box::new(RealFmt::RIEEE)),
            "VAX" => Some(Box::new(RealFmt::VAX)),
            _ => None
        }
    }
}



///////////////////////
/// SystemLabel
/// 
/// System labels describe the format of the image and how to access it. They are always the first labels in the
/// file. The system labels extend from the beginning of the file until the first PROPERTY or TASK keyword,
/// or until the end of the label (if there are no property or history labels).
/// 
///////////////////////

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum SystemLabel {
    LBLSIZE,            // integer - The size of the label storage area, in bytes
    FORMAT,             // string enum BYTE, HALF, FULL, REAL, DOUB, COMP, WORD, LONG, COMPLEX
                        //              The data type of the pixels in the image.
    TYPE,               // string enum IMAGE PARMS PARM PARAM GRAPH1 GRAPH2 GRAPH3
                        //              The kind of file this is.
    BUFSIZE,            // integer - This label item is obsolete. It formerly defined the size of the
                        //              internal buffer to use when reading the image, but it is no longer used.
    DIM,                // integer - The number of dimensions in the file, which is always equal to 3.
    EOL,                // integer - A flag indicating the existence of EOL labels (see above). If EOL=1, the labels are
                        //              present. If EOL=0 (or is absent), no EOL labels are present, and the entire label string is at the
                        //              front of the file.
    RECSIZE,            // integer - The size in bytes of each record in the VICAR file. It may be
                        //              calculated with the formula NBB + N1*pixel_size, where pixel_size is the size of each pixel
                        //              computed using FORMAT (for the pixel type) and the INTFMT or REALFMT (for the host
                        //              representation) labels.
    ORG,                // string - The organization of the file. 
    NL,                 // integer - The number of lines in the image (same as N2 for BSQ or N3 for BIL and BIP)
    NS,                 // integer - Number of samples in the image (same as N1 for BSQ and BIL or N2 for BIP).
    NB,                 // integer - Number of bands in the image (same as N3 for BSQ, N2 for BIL, or N1 for BIP)
    N1,                 // integer - The size (in pixels) of the first (fastest-varying) dimension. If not present, it defaults
                        //              to NS or NB, as appropriate.
    N2,                 // integer - The size of the second dimension. If not present, it defaults to NL, NS, or NB, as
                        //              appropriate
    N3,                 // integer - The size of the third (slowest-varying) dimension. If not present, it defaults to NL or
                        //              NB, as appropriate.
    N4,                 // integer - This item was to have been used for four-dimensional files, but this has not yet been
                        //              implemented. It defaults to 0.
    NBB,                // integer - The number of bytes of binary prefix before each record. Each and every record
                        //              consists of the pixels of the fastest-varying dimension, optionally preceded by a binary prefix. The
                        //              size (in bytes, not pixels) of this binary prefix is given by NBB, which defaults to 0. The binary
                        //              prefix and the binary header (see NLB) together make up the binary label. The format of data in
                        //              the binary label is application-defined. The BLTYPE label is intended to identify the format of the
                        //              binary label, but it is new and not widely used. Generally, the binary label should be ignored
                        //              unless the format of the data is known beforehand
    NLB,                // integer - The number of lines (records) of binary header at the top of the file. The optional
                        //              binary header occurs once in the file, between the main labels and the image data. It is not
                        //              repeated per third dimension. The size of the binary header in bytes is given by NLB * RECSIZE,
                        //              since NLB is a line count. NLB defaults to 0. Note that the binary header also includes space
                        //              reserved for the binary prefix (NBB), since NBB goes into RECSIZE. The binary header and the
                        //              binary prefix (see NBB) together make up the binary label. The format of data in the binary label
                        //              is application-defined. The BLTYPE label is intended to identify the format of the binary label,
                        //              but it is new and not widely used. Generally, the binary label should be ignored unless the format
                        //              of the data is known beforehand
    HOST,               // string enum - The type of computer used to generate the image. It is used only for documentation;
                        //              the INTFMT and REALFMT labels are used to determine the format of the pixels. Nevertheless, it
                        //              should be kept consistent with INTFMT and REALFMT. HOST defaults to VAX-VMS. The
                        //              value may be anything, as new computer types are occasionally added,
    INTFMT,             // string enum - The format used to represent integer pixels (BYTE, HALF, and FULL) in the
                        //              file. If INTFMT is not present, it defaults to LOW. Note that INTFMT should be present even if
                        //              the pixels are a floating-point type. T
    REALFMT,            // string enum - The format used to represent floating-point pixels (REAL, DOUB, and
                        //              COMP) in the file. If REALFMT is not present, it defaults to VAX. Note that REALFMT should
                        //              be present even if the pixels are an integral type.
    BHOST,              // string - The type of computer used to generate the binary label. It can take the same
                        //              values with the same meanings as HOST. The reason BHOST is separate is that the data in the
                        //              binary label may be in a different host representation than the pixels
    BINTFMT,            // string - The format used to represent integers in the binary label. It can take the same
                        //              values with the same meanings as INTFMT. The reason BINTFMT is separate is that the data in
                        //              the binary label may be in a different host representation than the pixels.
    BREALFMT,           // string - The format used to represent floating-point data in the binary label. It can
                        //              take the same values with the same meanings as REALFMT. The reason BREALFMT is separate
                        //              is that the data in the binary label may be in a different host representation than the pixels
    BLTYPE,             // string - The type of the binary label. This is not a data type, but is a string identifying the
                        //              kind of binary label in the file. It is used for documentation, and so application programs can
                        //              process the binary label correctly, without having to be told what kind it is. BLTYPE is new, and
                        //              is not yet used by any applications. It defaults to a null string. The valid values are maintained in a
                        //              name registry by the VICAR system programmer, which will document the actual data layout for
                        //              each BLTYPE. As of this writing, there are no names yet registered
}

/*
Each keyword-value pair is separated by spaces. Keywords are strings, up to 32
characters in length, and consist of uppercase characters, underscores (_), and numbers (but should start
with a letter). Values may be integer, real, or strings, and may be multiple (e.g. an array of 5 integers, but
types cannot be mixed in a single value). Spaces may appear on either side of the equals character (=), but
are not normally present.

The label values may be of three types: integer, real, or string
*/
pub struct KeyValuePair<A, B> {
    pub key:A,
    pub value:B
}

// impl<T> KeyValuePair<T> {

//     pub fn parse(s:String) -> KeyValuePair<T> {

//     }

// }